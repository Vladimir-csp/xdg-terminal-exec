#!/bin/sh
# Proposal for XDG terminal execution utility
#
# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.
#
# Contributors:
# Roman Chistokhodov https://github.com/FreeSlave/

# some transitional variables for desktop entries used here:
# ENTRY_FILE - desktop entry path relative to it's data directory
# ENTRY_ID - ENTRY_FILE with '/' swapped for '-' (see section E of Desktop Entry Spec)
# ENTRY_PATH - full path of specific desktop entry file

# Treat non-zero exit status from simple commands as an error
# Treat unset variables as errors when performing parameter expansion
set -eu

DATA_PREFIX_DIR=xdg-terminals
CONFIG_NAME=xdg-terminals.list

DATA_HIERARCHY="${XDG_DATA_HOME:-$HOME/.local/share}:${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
CONF_HIERARCHY="${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg:/usr/etc/xdg}"

BLACKLIST=''

OIFS="$IFS"

if [ "${DEBUG-0}" = '1' ]; then
	debug() { printf '%s\n' "$1" >&2; }
else
	debug() { :; }
fi

trim_start() {
	# Remove all but leading whitespace, and trim that from the given string
	printf '%s' "${1#"${1%%[![:space:]]*}"}"
}

trim_spaces() {
	TRIMVAR="$*"
	TRIMVAR="${TRIMVAR#"${TRIMVAR%%[![:space:]]*}"}"
	TRIMVAR="${TRIMVAR%"${TRIMVAR##*[![:space:]]}"}"
	printf '%s' "$TRIMVAR"
}

generate_config_list() {
	# Generate list of possible config files for current DE
	DESKTOPS_LC="$(printf '%s' "${XDG_CURRENT_DESKTOP-}" | tr '[:upper:]' '[:lower:]')"
	IFS=':'
	debug "lower case desktops are: '${DESKTOPS_LC}'"
	for CONFIG_DIR in $CONF_HIERARCHY; do
		for DESKTOP in $DESKTOPS_LC; do
			printf '%s\n' "${CONFIG_DIR}/${DESKTOP}${DESKTOP:+-}${CONFIG_NAME}"
		done
		printf '%s\n' "${CONFIG_DIR}/${CONFIG_NAME}"
	done | uniq
	IFS="$OIFS"
}

# Read config from given path, print sanitised entries
read_config_path() {
	config_path="$1"

	debug "reading config '$config_path'"
	[ -f "$config_path" ] || return 0
	# Let `read` trim leading/trailing whitespace from the line
	while read -r line; do
		debug "read line '$line'"
		case $line in
		# `[The extensionless entry filename] should be a valid D-Bus well-known name.`
		[A-Za-z_]*) printf '%s\n' "$line" ;;
		esac
		# By default empty lines and comments get ignored
	done < "$config_path"
}

find_preferred_entry() {
	# Read entries listed in config files until a valid one is found
	CONFIG_LIST="$(generate_config_list)"

	debug 'finding preferred entry in configs'

	while read -r CONFIG_FILE; do
		debug "looking for config '${CONFIG_FILE}'"
		for ENTRY_ID in $(read_config_path "$CONFIG_FILE"); do
			debug "retrieved entry ID '$ENTRY_ID'"
			check_entry_id "$ENTRY_ID" || continue

			debug "finding path for entry ID '$ENTRY_ID'"
			ENTRY_PATH="$(find_entry_path "$ENTRY_ID")"
			if [ -n "$ENTRY_PATH" ] && check_entry_path "$ENTRY_PATH"; then
				debug "file at path '$ENTRY_PATH' checks out"
				printf '%s' "$ENTRY_PATH"
				return 0
			else
				debug "entry ID '$ENTRY_ID' failed check at path '$ENTRY_PATH', blacklisting"
				BLACKLIST="${BLACKLIST}${BLACKLIST:+;}$ENTRY_ID"
				continue
			fi
		done
	done <<- EOF
		$CONFIG_LIST
	EOF
	return 1
}

find_any_entry() {
	# Read entries in data dirs until a valid one is found
	debug 'looking for first available entry in data hierarchy'
	IFS=':'
	for DATA_DIR in $DATA_HIERARCHY; do
		IFS="$OIFS"
		if [ -d "${DATA_DIR}/${DATA_PREFIX_DIR}" ]; then
			debug "searching in '${DATA_DIR}/${DATA_PREFIX_DIR}'"
			ENTRY_FILES="$(find -L "${DATA_DIR}/${DATA_PREFIX_DIR}" -type f -iname '*.desktop')"
			while read -r ENTRY_PATH; do
				[ -z "$ENTRY_PATH" ] && continue
				ENTRY_FILE="${ENTRY_PATH#"${DATA_DIR}/${DATA_PREFIX_DIR}/"}"
				ENTRY_ID="$(printf '%s' "$ENTRY_FILE" | tr '/' '-')"
				check_entry_id "$ENTRY_ID" || continue
				if check_entry_path "$ENTRY_PATH"; then
					debug "file at path '$ENTRY_PATH' checks out"
					printf '%s' "$ENTRY_PATH"
					return 0
				else
					debug "entry ID '$ENTRY_ID' failed check at path '$ENTRY_PATH', blacklisting"
					BLACKLIST="${BLACKLIST}${BLACKLIST:+;}$ENTRY_ID"
					debug "current blacklist: '$BLACKLIST'"
				fi
			done <<- EOF
				$ENTRY_FILES
			EOF
		fi
	done
	IFS="$OIFS"
	return 1
}

find_entry_path() {
	# For given desktop entry ID find an actual file path
	ENTRY_ID="$1"

	IFS=':'
	for DATA_DIR in $DATA_HIERARCHY; do
		IFS="$OIFS"
		if [ -d "${DATA_DIR}/${DATA_PREFIX_DIR}" ]; then
			debug "looking in '${DATA_DIR}/${DATA_PREFIX_DIR}'"
			ENTRY_FILES="$(find -L "${DATA_DIR}/${DATA_PREFIX_DIR}" -type f -iname '*.desktop')"
			while read -r ENTRY_PATH; do
				[ -z "$ENTRY_PATH" ] && continue
				ENTRY_FILE="${ENTRY_PATH#"${DATA_DIR}/${DATA_PREFIX_DIR}/"}"
				FOUND_ENTRY_ID="$(printf '%s' "$ENTRY_FILE" | tr '/' '-')"
				[ "$FOUND_ENTRY_ID" != "$ENTRY_ID" ] && continue
				debug "got entry path '$ENTRY_PATH'"
				printf '%s' "$ENTRY_PATH"
				return 0
			done <<- EOF
				$ENTRY_FILES
			EOF
		fi
	done
	IFS="$OIFS"
	debug "path not found for entry ID '$ENTRY_ID'"
	return 1
}

check_entry_id() {
	# Check if entry ID is blacklisted by previous checks
	ENTRY_ID="$1"

	debug "checking if ID '$ENTRY_ID' is in blacklist '$BLACKLIST'"
	IFS=';'
	for ITEM in $BLACKLIST; do
		IFS="$OIFS"
		if [ "$ENTRY_ID" = "$ITEM" ]; then
			debug 'blacklist positive'
			return 1
		fi
	done
	IFS="$OIFS"
	return 0
}

# Check validity of a given entry line
# Modifies following global variables:
# EXEC : Program to execute, possibly with arguments. See spec for details.
# EXECARG : Execution argument for the terminal emulator.
check_entry() {
	# Order of checks is important
	case $1 in
	'OnlyShowIn'*=*)
		onlyShowIn=$(trim_start "${1#*=}")
		debug "read OnlyShowIn '$onlyShowIn'"
		IFS=';'
		for name in $onlyShowIn; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				IFS="$OIFS"
				debug "checking OnlyShowIn match '$desktop'='$name'"
				[ "$desktop" = "$name" ] && return 0
			done
		done
		IFS="$OIFS"
		# Default in this case is to fail
		return 1
		;;
	'NotShowIn'*=*)
		notShowIn=$(trim_start "${1#*=}")
		debug "read NotShowIn '$notShowIn'"
		IFS=';'
		for name in $notShowIn; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				IFS="$OIFS"
				debug "checking NotShowIn match '$desktop'='$name'"
				[ "$desktop" = "$name" ] && return 1
			done
		done
		IFS="$OIFS"
		# Default in this case is to succeed
		return 0
		;;
	'X-ExecArg'*=*)
		# Set global variable
		EXECARG=$(trim_start "${1#*=}")
		debug "read execution argument '$EXECARG'"
		;;
	'ExecArg'*=*)
		# Set global variable
		EXECARG=$(trim_start "${1#*=}")
		debug "read execution argument '$EXECARG'"
		;;
	'TryExec'*=*)
		executable=$(trim_start "${1#*=}")
		debug "checking TryExec executable '$executable'"
		command -v "$executable" > /dev/null || return 1
		;;
	'Hidden'*=*)
		hidden=$(trim_start "${1#*=}")
		debug "checking Hidden boolean '$hidden'"
		[ "$hidden" = 'true' ] && return 1
		;;
	'Exec'*=*)
		# Set global variable
		EXEC=$(trim_start "${1#*=}")
		# Get first word from read Exec value
		eval "set -- $EXEC"
		exec0="$1"
		debug "checking Exec[0] executable '$exec0'"
		command -v "$exec0" > /dev/null || return 1
		;;
	esac
	# By default unrecognised keys, empty lines and comments get ignored
}

check_entry_path() {
	# Determine if entry in given path is valid for execution in current DE
	read_entry_path "$1"
}

# Read entry from given path, only parse 'Desktop Entry' group
read_entry_path() {
	entry_path="$1"

	debug "reading desktop entry '$entry_path'"
	# Let `read` trim leading/trailing whitespace from the line
	while read -r line; do
		case $line in
		# `There should be nothing preceding [the Desktop Entry group] in the desktop entry file but [comments]`
		'[Desktop Entry]'*) ;;
		# A `Key=Value` pair, check it
		[A-Za-z0-9-]*)
			check_entry "$line" && continue
			# Reset values that might have been set
			unset EXEC
			unset EXECARG
			return 1
			;;
		# Start of the next group header, stop
		'['*) break ;;
		esac
		# By default empty lines and comments get ignored
	done < "$entry_path"
	return 0
}

# See read_entry_path and check_entry
if find_preferred_entry > /dev/null || find_any_entry > /dev/null; then
	# Default to '-e' if unset
	EXECARG=${EXECARG-'-e'}
fi

if [ -z "${EXEC-}" ]; then
	# Set defaults
	EXEC='xterm'
	EXECARG='-e'
fi

# Store original argument list, before it's modified
ORIG_ARGV="$*"

# `Implementations must undo quoting [in the Exec argument(s)][...]`
if [ "$#" -gt 0 ]; then
	eval "set -- $EXEC ${EXECARG:+'"$EXECARG"'} \"\$@\""
else
	eval "set -- $EXEC"
fi

debug "EXEC=$EXEC
EXECARG=$EXECARG
ARGV=$ORIG_ARGV
Final argv (>arg< per line):
$(printf '>%s<\n' "$@")
End of final argv"

exec "$@"
