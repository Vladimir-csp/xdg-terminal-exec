#!/bin/sh
# Proposal for XDG terminal execution utility
#
# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.
#
# Contributors:
# Roman Chistokhodov    https://github.com/FreeSlave/
# fluvf                 https://github.com/fluvf

# Treat non-zero exit status from simple commands as an error
# Treat unset variables as errors when performing parameter expansion
# Disable pathname expansion
set -euf

# Store original IFS value, assumed to contain the default: <space><tab><newline>
OIFS="$IFS"
# Newline, utility variable used throughout the script
N='
'

check_bool() {
	case "$1" in
	true | True | TRUE | yes | Yes | YES | 1) return 0 ;;
	false | False | FALSE | no | No | NO | 0) return 1 ;;
	*)
		echo "Assuming '$1' means no" >&2
		return 1
		;;
	esac
}

if check_bool "${DEBUG-0}"; then
	debug() { printf '%s\n' "$1" >&2; }
else
	debug() { :; }
fi

# Find and print all config file paths
find_config_paths() {
	# Directories searched for config files, in decending order of preference
	config_directories="${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg}"
	# Config filename to parse
	config_file=xdg-terminals.list
	# Generate list of possible config files for current Dekstop Environment
	# TODO: Should this be case insensitive? Desktop entry checks that also use $XDG_CURRENT_DESKTOP are not
	lowercase_desktops="$(printf '%s' "${XDG_CURRENT_DESKTOP-}" | tr '[:upper:]' '[:lower:]')"
	debug "lowercase desktops are: '$lowercase_desktops'"
	# Loop through paths
	# TODO: Replace this by a find call?
	IFS=':'
	for directory in $config_directories; do
		for desktop in $lowercase_desktops; do
			printf '%s\n' "$directory"/"$desktop"-"$config_file"
		done
		printf '%s\n' "$directory"/"$config_file"
	done
}
# Mask IFS withing function to allow temporary changes
alias find_config_paths='IFS= find_config_paths'

# Parse all config files and populate $ENTRY_IDS with read desktop entry IDs
read_config_paths() {
	# All config files are read immediatelly, rather than on demand, even if it's more IO intensive
	# This way all IDs are already known, and in order of preference, before iterating over them
	# This allows for easier deduplication, when adding fallback IDs later on
	IFS="$N"
	for config_path in $(find_config_paths); do
		debug "reading config '$config_path'"
		# Nonexistant file is not an error
		[ -f "$config_path" ] || continue
		# Let `read` trim leading/trailing whitespace from the line
		while IFS="$OIFS" read -r line; do
			#debug "read line '$line'"
			case $line in
			# Whether to search for entries in 'xdg-terminals' or 'applications'
			# Can be overriden by $XTE_STOCK_TERMINALS
			/use_stock_applications | use_stock_applications)
				debug "found '$line' directive${XTE_STOCK_TERMINALS+ (ignored)}"
				XTE_STOCK_TERMINALS=${XTE_STOCK_TERMINALS-true}
				;;
			/use_xdg_terminals | use_xdg_terminals)
				debug "found '$line' directive${XTE_STOCK_TERMINALS+ (ignored)}"
				XTE_STOCK_TERMINALS=${XTE_STOCK_TERMINALS-false}
				;;
			# `[The extensionless entry filename] should be a valid D-Bus well-known name.`
			# `a sequence of non-empty elements separated by dots (U+002E FULL STOP),
			# none of which starts with a digit, and each of which contains only characters from the set [a-zA-Z0-9-_]`
			# Stricter parts seem to be related only to reversed DNS notation but not common naming
			# i.e. there is `2048-qt.desktop`.
			# I do not know of any terminal that starts with a number, but it's valid.
			[a-zA-Z0-9_]*)
				ENTRY_IDS=${ENTRY_IDS:+${ENTRY_IDS}${N}}$line
				debug "added ID '$line'"
				;;
			esac
			# By default empty lines and comments get ignored
		done < "$config_path"
	done
}
# Mask IFS withing function to allow temporary changes
alias read_config_paths='IFS= read_config_paths'

# Check if newline delimited list $1 contains string $2
contains() {
	IFS="$N"
	for item in $1; do
		[ "$item" = "$2" ] && return 0
	done
	return 1
}
# Mask IFS withing function to allow temporary changes
alias contains='IFS= contains'

# Find and map all desktop entry files from standardised paths into aliases
find_entry_paths() {
	# Directory hierarchy that is searched for desktop entry files
	data_directories="${XDG_DATA_HOME:-$HOME/.local/share}:${XDG_DATA_DIRS:-/usr/local/share/:/usr/share/}"
	# Select which subdirectory to search for terminal emulators in:
	# 'xdg-terminals', a sepparate directory that exists for this script specifically (default),
	# 'applications', the standardised location for application desktop entry files
	# When searching in 'applications', entries will be filtered based on their Category key
	if check_bool "${XTE_STOCK_TERMINALS-true}"; then
		data_subdirectory='applications'
	else
		data_subdirectory='xdg-terminals'
	fi
	debug "searching for terminal entries in '$data_subdirectory'"
	# Loop through paths
	IFS=':'
	for directory in $data_directories; do
		# Normalise base path and append the data subdirectory with a trailing '/'
		directory=${directory%/}/$data_subdirectory/
		debug "searching '$directory'"
		# Nonexistent directory is not an error
		[ -d "$directory" ] || continue
		# Loop through paths
		IFS="$N"
		# Print order of found files is unpredictable, sort them
		for entry_path in $(find -L "$directory" -type f -name '[[:alnum:]-_.]*.desktop' | sort); do
			entry_paths=${entry_paths:+${entry_paths}${N}}$entry_path
			# Remove data directory path from ID
			entry_ids=${entry_ids:+${entry_ids}${N}}${entry_path#"$directory"}
		done
	done
	# Convert all file path fragments into IDs in one operation
	entry_ids=$(printf '%s' "${entry_ids-}" | tr '/' '-')
	# Loop through paths and IDs simultaneously
	IFS="$N"
	while read -r entry_path && read -r entry_id <&3; do
		if [ -z "$entry_path" ] || [ -z "$entry_id" ]; then
			debug "empty data: entry_path: '$entry_path', entry_id: '$entry_id'"
			continue
		fi

		# since we are moving up the XDG heirarchy, the first encoutered path for entry ID is used
		if alias "$entry_id" > /dev/null 2>&1; then
			debug "skipped '$entry_path' as '$entry_id' (overridden earlier)"
		else
			# alias can fail on weird (invalid) entry ID
			# Could add a proper validator above, but might be too taxing doing it on all entries,
			# so this is just a first line of defence, more sensitive in bash than dash btw.
			# A proper validator is applied later on entry parsing.
			# shellcheck disable=SC2139
			if alias "$entry_id"="entry_path='$entry_path'" > /dev/null 2>&1; then
				debug "registered '$entry_path' as entry '$entry_id'"
				# add as fallback ID if was not already listed
				if ! contains "${ENTRY_IDS}${N}${FALLBACK_ENTRY_IDS}" "$entry_id"; then
					FALLBACK_ENTRY_IDS=${FALLBACK_ENTRY_IDS:+${FALLBACK_ENTRY_IDS}${N}}$entry_id
					debug "added fallback ID '$entry_id'"
				fi
			else
				echo "skipped '$entry_path' due to unsupported filename" >&2
			fi
		fi
		# Use '//' as delimiter, as it can't be found within valid paths nor IDs
	done <<- // 3<<- //
		${entry_paths-}
	//
		${entry_ids-}
	//
}
# Mask IFS withing function to allow temporary changes
alias find_entry_paths='IFS= find_entry_paths'

# Check validity of a given entry key - value pair
# Modifies following global variables:
# EXEC : Program to execute, possibly with arguments. See spec for details.
# EXECARG : Execution argument for the terminal emulator.
# TERMINAL : Set if application has been categorized as a terminal emulator
check_entry_key() {
	key="$1"
	value="$2"
	action="$3"
	read_exec="$4"
	de_checks="$5"

	# Order of checks is important
	case $key in
	'Categories'*=*)
		# Enforce only if reading from 'applications' subdirectory
		! check_bool "${XTE_STOCK_TERMINALS-true}" && return 0
		debug "checking for 'TerminalEmulator' in Categories '$value'"
		IFS=';'
		for category in $value; do
			[ "$category" = "TerminalEmulator" ] && {
				TERMINAL=true
				return 0
			}
		done
		# Default in this case is to fail
		return 1
		;;
	'Actions'*=*)
		# `It is not valid to have an action group for an action identifier not mentioned in the Actions key.
		# Such an action group must be ignored by implementors.`
		# ignore if no action requested
		[ -z "$action" ] && return 0
		debug "checking for '$action' in Actions '$value'"
		IFS=';'
		for check_action in $value; do
			[ "$check_action" = "$action" ] && return 0
		done
		# Default in this case is to fail
		return 1
		;;
	'OnlyShowIn'*=*)
		case "$de_checks" in
		true) debug "checking for intersecion between '${XDG_CURRENT_DESKTOP-}' and OnlyShowIn '$value'" ;;
		false)
			debug "skipping OnlyShowIn check"
			return 0
			;;
		esac
		IFS=';'
		for target in $value; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				[ "$desktop" = "$target" ] && return 0
			done
		done
		# Default in this case is to fail
		return 1
		;;
	'NotShowIn'*=*)
		case "$de_checks" in
		true) debug "checking for intersecion between '${XDG_CURRENT_DESKTOP-}' and NotShowIn '$value'" ;;
		false)
			debug "skipping NotShowIn check"
			return 0
			;;
		esac
		IFS=';'
		for target in $value; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				debug "checking NotShowIn match '$desktop'='$target'"
				[ "$desktop" = "$target" ] && return 1
			done
		done
		# Default in this case is to succeed
		return 0
		;;
	'X-ExecArg'*=* | 'ExecArg'*=*)
		# Set global variable
		EXECARG=$value
		debug "read ExecArg '$EXECARG'"
		;;
	'TryExec'*=*)
		debug "checking TryExec executable '$value'"
		command -v "$value" > /dev/null || return 1
		;;
	'Hidden'*=*)
		debug "checking boolean Hidden '$value'"
		[ "$value" = 'true' ] && return 1
		;;
	'Exec'*=*)
		case "$read_exec" in
		false)
			debug "ignored Exec from wrong section"
			return 0
			;;
		esac
		debug "read Exec '$value'"
		# Set global variable
		EXEC=$value
		# Get first word from read Exec value
		IFS="$OIFS"
		eval "set -- $EXEC"
		debug "checking Exec[0] executable '$1'"
		command -v "$1" > /dev/null || return 1
		;;
	esac
	# By default unrecognised keys, empty lines and comments get ignored
}
# Mask IFS withing function to allow temporary changes
alias check_entry='IFS= check_entry'

# Read entry from given path
read_entry_path() {
	entry_path="$1"
	entry_action="$2"
	de_checks="$3"
	read_exec=false
	# shellcheck disable=SC2016
	debug "reading desktop entry '$entry_path'${entry_action:+ action '}$entry_action${entry_action:+'}"
	# Let `read` trim leading/trailing whitespace from the line
	while IFS="$OIFS" read -r line; do
		case $line in
		# `There should be nothing preceding [the Desktop Entry group] in the desktop entry file but [comments]`
		# if entry_action is not requested, allow reading Exec right away from the main group
		'[Desktop Entry]'*) [ -z "$entry_action" ] && read_exec=true ;;
		# A `Key=Value` pair
		[a-zA-Z0-9-]*)
			# Split value from pair
			value=${line#*=}
			# Remove all but leading spaces, and trim that from the value
			value=${value#"${value%%[! ]*}"}
			# Check the key
			check_entry_key "$line" "$value" "$entry_action" "$read_exec" "$de_checks" && continue
			# Reset values that might have been set
			unset EXEC
			unset EXECARG
			unset TERMINAL
			# shellcheck disable=SC2016
			debug "entry discarded"
			return 1
			;;
		# found requested action, allow reading Exec
		"[Desktop Action ${entry_action}]"*) read_exec=true ;;
		# Start of the next group header, stop if already read exec
		'['*) [ "$read_exec" = "true" ] && break ;;
		esac
		# By default empty lines and comments get ignored
	done < "$entry_path"
}

validate_entry_action_id() {
	# validates entry ($1) and action ID ($2) strings
	check=true

	case "$1" in
	# invalid characters or degrees of emptiness
	*[!a-zA-Z0-9-_.]* | *[!a-zA-Z0-9-_.] | [!a-zA-Z0-9-_.]* | [!a-zA-Z0-9-_.] | '' | .desktop)
		echo "Skipping unsupported Entry ID '$1'" >&2
		check=false
		;;
	# all that left with .desktop
	*.desktop) true ;;
	# and without
	*)
		echo "Skipping unsupported Entry ID '$1'" >&2
		check=false
		;;
	esac

	case "$2" in
	# invalid characters
	*[!a-zA-Z0-9-]* | *[!a-zA-Z0-9-] | [!a-zA-Z0-9-]* | [!a-zA-Z0-9-])
		echo "Invalid action ID '$check_action_id'" >&2
		check=false
		;;
	# all that left or nothing
	'' | *) true ;;
	esac

	[ "$check" = "true" ] && return 0 || return 1
}

# Loop through IDs and try to find a valid entry
find_entry() {
	# for explicitly listed entries do not apply DE *ShowIn limits
	de_checks=false
	IFS="$N"
	for entry_id in ${ENTRY_IDS}${N}//fallback_start//${N}$FALLBACK_ENTRY_IDS; do
		case "$entry_id" in
		# entry has an action appended
		*:*)
			entry_action=${entry_id#*:}
			entry_id=${entry_id%:*}
			;;
		# skip empty line
		'') continue ;;
		# fallback entries ahead, enable *ShowIn checks
		'//fallback_start//')
			de_checks=true
			continue
			;;
		# nullify action
		*) entry_action='' ;;
		esac
		validate_entry_action_id "$entry_id" "$entry_action" || continue

		debug "matching path for entry ID '$entry_id'"
		# Check if a matching path was found for ID
		alias "$entry_id" > /dev/null 2>&1 || continue
		# Evaluates the alias, it sets $entry_path
		eval "$entry_id"
		read_entry_path "$entry_path" "$entry_action" "$de_checks" || continue
		# Check that the entry is actually executable
		[ -z "${EXEC-}" ] && continue
		# ensure entry is a Terminal Emulator when using stock applications
		check_bool "${XTE_STOCK_TERMINALS-true}" && [ -z "${TERMINAL-}" ] && continue
		# Set defaults
		: "${EXECARG="-e"}"
		# Entry is valid, stop
		return 0
	done
	echo "No valid terminal entry was found in ${data_subdirectory}" >&2
	return 1
}
# Mask IFS withing function to allow temporary changes
alias find_entry='IFS= find_entry'

# All desktop entry ids in descending order of preference from *xdg-terminals.list configs, with duplicates removed
ENTRY_IDS=''
# All desktop entry ids found in data dirs in descending order of preference, with duplicates (including $ENTRY_IDS) removed
FALLBACK_ENTRY_IDS=''
# Modifies $ENTRY_IDS
read_config_paths
# Modifies $ENTRY_IDS and sets global aliases
find_entry_paths

debug "final entry ID list:${ENTRY_IDS:+$N}$ENTRY_IDS
end of final entry ID list"
debug "final fallback entry ID list:${FALLBACK_ENTRY_IDS:+$N}$FALLBACK_ENTRY_IDS
end of final fallback entry ID list"

find_entry || exit 1

# Store original argument list, before it's modified
ORIG_ARGV="$*"

# `Implementations must undo quoting [in the Exec argument(s)][...]`
if [ "$#" -gt 0 ]; then
	eval "set -- $EXEC ${EXECARG:+'"$EXECARG"'} \"\$@\""
else
	eval "set -- $EXEC"
fi

debug "EXEC=$EXEC
EXECARG=$EXECARG
ARGV=$ORIG_ARGV
final argv (>arg< per line):
$(printf '>%s<\n' "$@")
end of final argv"

exec "$@"
