#!/bin/sh
# Proposal for XDG terminal execution utility
#
# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.
#
# Contributors:
# Roman Chistokhodov    https://github.com/FreeSlave/
# fluvf                 https://github.com/fluvf

# Treat non-zero exit status from simple commands as an error
# Treat unset variables as errors when performing parameter expansion
# Disable pathname expansion
set -euf

# Store original IFS value, assumed to contain the default: <space><tab><newline>
OIFS="$IFS"
# Newline, utility variable used throughout the script
N='
'

# Utility function to print messages to stderr
error() { printf 'ERROR: %s\n' "$@" >&2; }

check_bool() {
	case "$1" in
	true | True | TRUE | yes | Yes | YES | 1) return 0 ;;
	false | False | FALSE | no | No | NO | 0) return 1 ;;
	*)
		error "Assuming '$1' means no"
		return 1
		;;
	esac
}

# Utility function to print debug messages to stderr (or not)
if check_bool "${DEBUG-0}"; then
	# Expand <tab> in debug messages to tab stop (long enough for most entry IDs)
	debug() { printf '%s\n' "$@" | expand -t 64 >&2; }
else
	debug() { :; }
fi

# Populates global constants and lists for later use and iteration
make_paths() {
	IFS=':'

	# Populate list of config files to read, in descending order of preference
	for dir in ${XDG_CONFIG_HOME:-"${HOME}/.config"}${IFS}${XDG_CONFIG_DIRS:-/etc/xdg}; do
		# Normalise base path and append the data subdirectory with a trailing '/'
		for desktop in ${LOWERCASE_XDG_CURRENT_DESKTOP}; do
			CONFIGS=${CONFIGS:+${CONFIGS}${IFS}}${dir%/}/${desktop}-xdg-terminals.list
		done
		CONFIGS=${CONFIGS:+${CONFIGS}${IFS}}${dir%/}/xdg-terminals.list
	done

	# Populate list of directories to search for entries in, in ascending order of preference
	for dir in ${XDG_DATA_HOME:-${HOME}/.local/share}${IFS}${XDG_DATA_DIRS:-/usr/local/share:/usr/share}; do
		# Normalise base path and append the data subdirectory with a trailing '/'
		APPLICATIONS_DIRS=${dir%/}/applications/${APPLICATIONS_DIRS:+${IFS}${APPLICATIONS_DIRS}}
	done

	# cache
	XDG_CACHE_HOME=${XDG_CACHE_HOME:-"${HOME}/.cache"}
	CACHE_FILE="${XDG_CACHE_HOME}/xdg-terminal-exec"

	debug "CONFIG:	$CONFIGS" "APPLICATIONS_DIRS:	$APPLICATIONS_DIRS" ''
}
# Mask IFS withing function to allow temporary changes
alias make_paths='IFS= make_paths'

gen_hash() {
	# return md5 of XDG_CURRENT DESKTOP and ls -LRl output for config and data paths
	# md5 is 4x faster than sha*, and there is no need for cryptography here
	# shellcheck disable=SC2034
	read -r hash drop <<- EOH
		$(
			hash_paths="${CONFIGS}:${APPLICATIONS_DIRS}"
			{
				echo "${XDG_CURRENT_DESKTOP-}"
				IFS=':'
				# shellcheck disable=SC2086
				debug ">     hashing '${XDG_CURRENT_DESKTOP-}' and listing of:" $hash_paths "^     end of hash listing"
				# shellcheck disable=SC2012,SC2086
				LANG=C ls -LRl ${hash_paths} 2> /dev/null
			} | md5sum 2> /dev/null
		)
	EOH
	case "$hash" in
	[0-9a-f]??????????????????????????????[0-9a-f])
		debug "got fresh hash '$hash'"
		echo "$hash"
		return 0
		;;
	*)
		debug "failed to get fresh hash, got '$hash'"
		return 1
		;;
	esac
}

read_cache() {
	# reads $cached_hash, $cached_exec, $cached_execarg, $cached_cmd from cache file,
	# checks if cache is actual and applies it, otherwise returns 1
	# tries to bail out as soon as possible if something does not fit
	if [ -f "${CACHE_FILE}" ]; then
		IFS=${N}
		line_num=0
		while read -r line; do
			line_num=$((line_num + 1))
			case "${line_num}_${line}" in
			1_[0-9a-f]??????????????????????????????[0-9a-f]) cached_hash=$line ;;
			2_*) cached_exec=$line ;;
			3_ | 3_*) cached_execarg=$line ;;
			4_*)
				# get cmd and break right away, line_num will be left at 4
				cached_cmd=$line
				break
				;;
			*)
				debug "cache line ${line_num} is invalid: ${line}"
				return 1
				;;
			esac
		done < "${CACHE_FILE}"
		if [ "$line_num" = "4" ]; then
			debug "got cache:" "${cached_hash}" "${cached_exec}" "${cached_execarg}" "${cached_cmd}"
			IFS=$OIFS
			HASH=$(gen_hash) || return 1
			if [ "$HASH" = "$cached_hash" ] && command -v "$cached_cmd" > /dev/null; then
				debug "cache is actual"
				EXEC=${cached_exec}
				EXECARG=${cached_execarg}
				return 0
			else
				debug "cache is out-of-date"
				return 1
			fi
		else
			debug "invalid cache data"
			return 1
		fi
	else
		debug "no cache data"
		return 1
	fi
}
# Mask IFS withing function to allow temporary changes
alias read_cache='IFS= read_cache'

save_cache() {
	# saves $HASH, $EXEC, $EXECARG, $1 (executable) to cache file or removes it if CACHE_ENABLE is false
	if check_bool "$CACHE_ENABLED"; then
		[ ! -d "${XDG_CACHE_HOME}" ] && mkdir -p "${XDG_CACHE_HOME}"
		if [ -z "${HASH-}" ]; then
			HASH=$(gen_hash) || {
				echo "could not hash listing, removing '${CACHE_FILE}'" >&2
				rm -f "${CACHE_FILE}"
				return 0
			}
		fi
		UM=$(umask)
		umask 0077
		printf '%s\n' "${HASH}" "${EXEC}" "${EXECARG}" "${1}" > "${CACHE_FILE}"
		umask "$UM"
		debug ">     saved cache:" "${HASH}" "${EXEC}" "${EXECARG}" "${1}" "^     end of saved cache"
	else
		debug "cache is disabled, removing '${CACHE_FILE}'"
		rm -f "${CACHE_FILE}"
		return 0
	fi
}

# Parse all config files and populate $READ_ENTRY_IDS with read desktop entry IDs
read_config_paths() {
	debug '' '    > reading terminal list files:'
	# All config files are read immediatelly, rather than on demand, even if it's more IO intensive
	# This way all IDs are already known, and in order of preference, before iterating over them
	IFS=':'
	for config_path in ${CONFIGS}; do
		# Nonexistant file is not an error
		[ -f "$config_path" ] || continue
		debug '' "    $config_path"
		# Let `read` trim leading/trailing whitespace from the IDs
		while IFS=":$OIFS" read -r entry_id action_id; do
			# Keep track of linenumber for error messages
			linenum=$((linenum += 1))
			# Rejoin the line for easier checks
			case "$entry_id:$action_id" in
			# Directives to toggle cache
			'/enable_cache:')
				debug "directive	$entry_id ${XTE_CACHE_ENABLED+'(ignored)'}"
				CACHE_ENABLED=${XTE_CACHE_ENABLED-true}
				;;
			'/disable_cache:')
				debug "directive	$entry_id ${XTE_CACHE_ENABLED+'(ignored)'}"
				CACHE_ENABLED=${XTE_CACHE_ENABLED-false}
				;;
			# Ignore comments and empty lines
			'#'* | ':') ;;
			# Sorry for the liberal paraphrasing
			# `[The extensionless entry filename comprises of dot separated elements] each of which contains only [...] [A-Za-z0-9-_]`
			# Catch and warn on invalid IDs
			*[![:alnum:]_.-]*'.desktop:'* | *'.desktop:'*[![:alnum:]_.-]* | '.desktop:'*)
				error "$config_path: line $linenum: discarded invalid entry"
				;;
			# Catch valid entry ID
			[[:alnum:]_]*'.desktop:'*)
				READ_ENTRY_IDS=${READ_ENTRY_IDS:+${READ_ENTRY_IDS}${N}}$entry_id:$action_id
				debug "$entry_id	: $action_id"
				;;
			# Catch and complain on invalid lines
			*)
				debug "line $linenum: discarded invalid line"
				;;
			esac
		done < "$config_path"
	done
}
# Mask IFS withing function to allow temporary changes
alias read_config_paths='IFS= read_config_paths'

replace() {
	# takes $1, finds $2, replaces with $3
	# does it in large chunks

	# var to be modified
	string=${1}
	# right part of string
	r_string=${1}
	# left part of string
	l_string=''
	# previous right part of string
	prev_r_string=''
	while true; do
		# save previous r_string
		prev_r_string=${r_string}
		# cut the right part with search string from the left
		r_string=${r_string#*"${2}"}
		# cut the left part with search string and rigth part from the right
		l_string=${string%"${2}${r_string}"}
		case "$r_string" in
		# if the right part was not unmodified, there is nothing to replace
		"$prev_r_string") break ;;
		# if the right part was is modified, update string with:
		# the left part, replace string, the right part
		*) string=${l_string}${3}${r_string} ;;
		esac
	done
	echo "$string"
}

# Find and map all desktop entry files from standardised paths into aliases
find_entry_paths() {
	# Append application directory paths to be searched
	IFS=':'
	for directory in $APPLICATIONS_DIRS; do
		# Append '.' to delimit start of entry ID
		set -- "$@" "$directory".
	done

	# Find all desktop entries with valid names
	set -- "$@" -type f -name '[a-zA-Z0-9_]*.desktop' ! -path '*[^a-zA-Z0-9_./-]*'

	debug '' '    > mapping entry IDs to paths:'
	# Loop through found entry paths and IDs
	IFS=$N
	while read -r entry_path && read -r entry_id; do
		# Entries are checked in ascending order of preference, so use last found if duplicate
		# shellcheck disable=SC2139
		alias "$entry_id"="entry_path='$entry_path'"
		debug "$entry_id	-> $entry_path"
		# Prepend to list of found IDs
		FOUND_ENTRY_IDS=${entry_id}${FOUND_ENTRY_IDS:+${N}${FOUND_ENTRY_IDS}}
	done <<- EOE
		$(
			# Don't complain about nonexistent directories
			find -L "$@" 2> /dev/null |
				# Print entry path and convert it into an ID and print that too
				awk '{ print; sub(".*/[.]/", ""); gsub("/", "-"); print }'
		)
	EOE

	debug '' '    > final list of found entry IDs:' ${FOUND_ENTRY_IDS:+"$FOUND_ENTRY_IDS"} ''
}
# Mask IFS withing function to allow temporary changes
alias find_entry_paths='IFS= find_entry_paths'

# Check validity of a given entry key - value pair
# Modifies following global variables:
# EXEC : Program to execute, possibly with arguments. See spec for details.
# EXECARG : Execution argument for the terminal emulator.
# TERMINAL : Set if application has been categorized as a terminal emulator
check_entry_key() {
	key="$1"
	value="$2"
	action_id="$3"

	case $key in
	'X-ExecArg' | 'ExecArg') check_entry_execarg "$value" ;;
	'Categories') check_entry_categories "$value" ;;
	'OnlyShowIn') check_entry_onlyshowin "$value" ;;
	'NotShowIn') check_entry_notshowin "$value" ;;
	'Actions') check_entry_actions "$value" "$action_id" ;;
	'TryExec') check_entry_tryexec "$value" ;;
	'Hidden') check_entry_hidden "$value" ;;
	# Only read key from requested action group, marked by unset ID
	'Exec') [ -z "$action_id" ] && check_entry_exec "$value" ;;
	esac
	# By default unrecognised keys, empty lines and comments get ignored
}
# Mask IFS withing function to allow temporary changes
alias check_entry_key='IFS= check_entry_key'

# Bellow are all entry validating subfunctions, each responsible for a single key - value pair.
# They're all in their own functions to make test writing more straight forward,
# and to make hiding them conditionally possible. See `find_entry`.
# Function `check_entry` is responsible for masking IFS etc. for them when called

check_entry_categories() {
	debug "Categories	'$1'"
	IFS=';'
	for category in $1; do
		if [ "$category" = "TerminalEmulator" ]; then
			TERMINAL=true
			return 0
		fi
	done
	# Default in this case is to fail
	return 1
}

check_entry_onlyshowin() {
	debug "OnlyShowIn	'${XDG_CURRENT_DESKTOP-}' <-> '$1'"
	IFS=';'
	for target in $1; do
		IFS=':'
		for desktop in ${XDG_CURRENT_DESKTOP-}; do
			[ "$desktop" = "$target" ] && return 0
		done
	done
	# Default in this case is to fail
	return 1
}

check_entry_notshowin() {
	debug "NotShowIn	'${XDG_CURRENT_DESKTOP-}' <-> '$1'"
	IFS=';'
	for target in $1; do
		IFS=':'
		for desktop in ${XDG_CURRENT_DESKTOP-}; do
			[ "$desktop" = "$target" ] && return 1
		done
	done
	# Default in this case is to succeed
	return 0
}

check_entry_execarg() {
	debug "ExecArg	'$1'"
	# Set global variable
	EXECARG=$1
}

check_entry_actions() {
	# Ignore if no action ID was given
	[ -z "$2" ] && return 0
	debug "Actions	'$1' <-> '$2'"
	IFS=';'
	for action in $1; do
		[ "$action" = "$2" ] && return 0
	done
	# `[Action groups not mentioned in the Actions key] must be ignored by implementors.`
	return 1
}

check_entry_tryexec() {
	debug "TryExec	'$1'"
	command -v "$1" > /dev/null || return 1
}

check_entry_hidden() {
	debug "Hidden	'$1'"
	[ "$1" = 'true' ] && return 1
}

check_entry_exec() {
	debug "Exec	'$1'"
	# Set global variable
	EXEC=$1
	# Get first word from read Exec value
	IFS="$OIFS"
	eval "set -- $EXEC"
	command -v "$1" > /dev/null || return 1
}

# Read entry from given path
read_entry_path() {
	entry_path="$1"
	action_id="$2"

	debug "    -> $entry_path"
	# Let `read` trim leading/trailing spaces from the key and value
	while IFS="= " read -r key value; do
		# Rejoin the line for easier checks
		case "$key $value" in
		# Consume the main entry group
		'[Desktop Entry]') ;;
		# Consume given action group
		"[Desktop Action ${action_id-}]") unset action_id ;;
		# Start of the next group header, stop if action has been consumed
		'['*) [ -z "${action_id-}" ] && break ;;
		# A `Key=Value` pair
		[a-zA-Z0-9-]*)
			# Check the pair and continue if valid
			check_entry_key "$key" "$value" "${action_id-}" && continue
			# Reset values that might have been set
			unset EXEC
			unset EXECARG
			unset TERMINAL
			return 1
			;;
		esac
		# By default empty lines and comments get ignored
	done < "$entry_path"
}

# Loop through IDs and try to find a valid entry
find_entry() {
	debug '' '    > checking entries:'

	# Do not enforce *ShowIn checks with explicitly listed entries
	alias check_entry_onlyshowin=':'
	alias check_entry_notshowin=':'
	while IFS=':' read -r entry_id action_id; do
		# Fallback to all found unchecked entries, enable *ShowIn checks
		if [ "$entry_id" = '//fallback_start//' ]; then
			unalias check_entry_onlyshowin
			unalias check_entry_notshowin
			continue
		fi
		debug '' "$entry_id	${action_id:+": $action_id"}"
		# Check if a matching path was found for ID
		alias "$entry_id" > /dev/null 2>&1 || continue
		# Evaluate the alias, it sets $entry_path
		eval "$entry_id"
		# Unset the alias, so duplicate entries are skipped
		unalias "$entry_id"
		read_entry_path "$entry_path" "$action_id" || continue
		# Check that the entry is a Terminal Emulator
		[ -z "${TERMINAL-}" ] && continue
		# Check that the entry is executable
		[ -z "${EXEC-}" ] && continue
		# Set defaults
		: "${EXECARG="-e"}"
		# Entry is valid, stop
		debug '    ^ entry valid' '' "    EXEC=$EXEC" "    EXECARG=$EXECARG" ''
		return 0
	done <<- EOE
		$READ_ENTRY_IDS
		//fallback_start//
		$FOUND_ENTRY_IDS
	EOE
	debug '' 'exhausted list of entry IDs' ''
	return 1
}

## globals
LOWERCASE_XDG_CURRENT_DESKTOP=$(echo "${XDG_CURRENT_DESKTOP-}" | tr '[:upper:]' '[:lower:]')

# this will receive proper value later
APPLICATIONS_DIRS=''

# path iterators
make_paths

# At this point we have no way of telling if cache is enabled or not, unless XTE_CACHE_ENABLED is set,
# so just try reading it as if default is true, otherwise do the usual thing.
# Editing config to disable cache should invalidate the cache.
# The true default is false though:
CACHE_ENABLED=${XTE_CACHE_ENABLED-false}

# HASH can be reused
HASH=''

if check_bool "${XTE_CACHE_ENABLED-true}" && read_cache; then
	CACHE_USED=true
else
	# continue with globals
	CACHE_USED=false

	# All desktop entry IDs read from *xdg-terminals.list files, in descending order of preference
	READ_ENTRY_IDS=''
	# All desktop entry IDs found in application directories, in descending order of preference
	FOUND_ENTRY_IDS=''

	# Modifies $READ_ENTRY_IDS
	read_config_paths
	# Modifies $FOUND_ENTRY_IDS and sets global aliases
	find_entry_paths

	# walk ID lists and find first applicable
	if ! find_entry; then
		error 'No valid entry was found'
		exit 1
	fi
fi

# Print original argument list, before it's modified
debug '' '    > given ARGV list:' "$@" ''

# drop -e or custom ExecArg if given as the first arg
case "${1-}" in
'-e' | "$EXECARG")
	debug "dropped '$1' from list"
	shift
	;;
esac

# `Implementations must undo quoting [in the Exec argument(s)][...]`
if [ "$#" -gt 0 ]; then
	eval "set -- $EXEC ${EXECARG:+'"$EXECARG"'} \"\$@\""
else
	eval "set -- $EXEC"
fi

debug '' '    > final ARGV list:' "$@" ''

if [ "$CACHE_USED" = "false" ]; then
	# saves or removes cache, forked out of the way
	save_cache "$1" &
fi

exec "$@"
