#!/bin/sh
# Proposal for XDG terminal execution utility
#
# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.
#
# Contributors:
# Roman Chistokhodov    https://github.com/FreeSlave/
# fluvf                 https://github.com/fluvf

# Treat non-zero exit status from simple commands as an error
# Treat unset variables as errors when performing parameter expansion
set -eu

# Backup original IFS value
# It is assumed that $OIFS contains the default IFS value
OIFS="$IFS"
# Newline, utility variable used throughout the script
N='
'

trim_start() {
	# Remove all but leading whitespace, and trim that from the given string
	printf '%s' "${1#"${1%%[![:space:]]*}"}"
}

check_bool() {
	case "$1" in
	true | True | TRUE | yes | Yes | YES | 1) return 0 ;;
	false | False | FALSE | no | No | NO | 0) return 1 ;;
	*)
		echo "Assuming \"$1\" means no" >&2
		return 1
		;;
	esac
}

append() {
	# returns $N-separated list $1 with $2 item appended if not already there
	IFS="$N"
	FOUND=0
	while read -r ITEM; do
		[ -n "$ITEM" ] && printf '%s\n' "$ITEM"
		[ "$ITEM" = "$2" ] && FOUND=1
	done <<- EOL
		$1
	EOL
	if [ "$FOUND" = "0" ]; then
		printf '%s\n' "$2"
	fi
	IFS="$OIFS"
}

if check_bool "${DEBUG-0}"; then
	debug() { printf '%s\n' "$1" >&2; }
else
	debug() { :; }
fi

# Read config from given path, print sanitised entries
read_config_path() {
	config_path="$1"

	debug "reading config '$config_path'"
	[ -f "$config_path" ] || return 0
	# Let `read` trim leading/trailing whitespace from the line
	while read -r line; do
		debug "read line '$line'"
		case $line in
		# `[The extensionless entry filename] should be a valid D-Bus well-known name.`
		[A-Za-z_]*) printf '%s\n' "$line" ;;
		esac
		# By default empty lines and comments get ignored
	done < "$config_path"
}

# Find a matching file path for a given entry ID
find_entry_path() {
	entry_id="$1"
	debug "finding path for entry id '$entry_id'"

	# Loop through paths, any empty lines should be discarded by word splitting
	IFS="$N"
	for entry_path in $ENTRY_PATHS; do
		debug "checking entry '$entry_path'"
		# ID is path without '$data_dir/$DATA_PREFIX_DIR//'
		found_entry_id="${entry_path#*//}"
		# Remove '//' from desktop entry path
		entry_path="${entry_path%//*}"/"$found_entry_id"
		found_entry_id="$(printf '%s' "$found_entry_id" | tr '/' '-')"
		debug "checking entry id '$found_entry_id'"
		[ "$found_entry_id" != "$entry_id" ] && continue
		debug "found entry path '$entry_path'"
		printf '%s' "$entry_path"
		return 0
	done
	IFS="$OIFS"
	debug 'no matching entry path found'
	return 1
}

# Check validity of a given entry line
# Modifies following global variables:
# EXEC : Program to execute, possibly with arguments. See spec for details.
# EXECARG : Execution argument for the terminal emulator.
check_entry() {
	# Order of checks is important
	case $1 in
	'OnlyShowIn'*=*)
		onlyShowIn=$(trim_start "${1#*=}")
		debug "read OnlyShowIn '$onlyShowIn'"
		IFS=';'
		for name in $onlyShowIn; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				IFS="$OIFS"
				debug "checking OnlyShowIn match '$desktop'='$name'"
				[ "$desktop" = "$name" ] && return 0
			done
		done
		IFS="$OIFS"
		# Default in this case is to fail
		return 1
		;;
	'NotShowIn'*=*)
		notShowIn=$(trim_start "${1#*=}")
		debug "read NotShowIn '$notShowIn'"
		IFS=';'
		for name in $notShowIn; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				IFS="$OIFS"
				debug "checking NotShowIn match '$desktop'='$name'"
				[ "$desktop" = "$name" ] && return 1
			done
		done
		IFS="$OIFS"
		# Default in this case is to succeed
		return 0
		;;
	'X-ExecArg'*=*)
		# Set global variable
		EXECARG=$(trim_start "${1#*=}")
		debug "read execution argument '$EXECARG'"
		;;
	'ExecArg'*=*)
		# Set global variable
		EXECARG=$(trim_start "${1#*=}")
		debug "read execution argument '$EXECARG'"
		;;
	'TryExec'*=*)
		executable=$(trim_start "${1#*=}")
		debug "checking TryExec executable '$executable'"
		command -v "$executable" > /dev/null || return 1
		;;
	'Hidden'*=*)
		hidden=$(trim_start "${1#*=}")
		debug "checking Hidden boolean '$hidden'"
		[ "$hidden" = 'true' ] && return 1
		;;
	'Exec'*=*)
		# Set global variable
		EXEC=$(trim_start "${1#*=}")
		# Get first word from read Exec value
		eval "set -- $EXEC"
		exec0="$1"
		debug "checking Exec[0] executable '$exec0'"
		command -v "$exec0" > /dev/null || return 1
		;;
	esac
	# By default unrecognised keys, empty lines and comments get ignored
}

# Read entry from given path, only parse 'Desktop Entry' group
read_entry_path() {
	entry_path="$1"
	debug "reading desktop entry '$entry_path'"
	# failsafe for empty entries
	HAS_DATA=false
	# Let `read` trim leading/trailing whitespace from the line
	while read -r line; do
		case $line in
		# `There should be nothing preceding [the Desktop Entry group] in the desktop entry file but [comments]`
		'[Desktop Entry]'*) ;;
		# A `Key=Value` pair, check it
		[A-Za-z0-9-]*)
			HAS_DATA=true
			check_entry "$line" && continue
			# Reset values that might have been set
			unset EXEC
			unset EXECARG
			return 1
			;;
		# Start of the next group header, stop
		'['*) break ;;
		esac
		# By default empty lines and comments get ignored
	done < "$entry_path"
	case $HAS_DATA in
	true) return 0 ;;
	false) return 1 ;;
	esac
}

# Name of config files to search and read
CONFIG_NAME=xdg-terminals.list

# Directory hierarchy searched for terminal config and desktop entry files
DATA_HIERARCHY="${XDG_DATA_HOME:-$HOME/.local/share}:${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
CONF_HIERARCHY="${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg:/usr/etc/xdg}"

# All desktop entry paths in descending order of preference
ENTRY_PATHS=''
# All desktop entry ids in descending order of preference
ENTRY_IDS=''

# Generate list of possible config files for current DE
# TODO: Should this be case insensitive? Desktop entry checks that also use $XDG_CURRENT_DESKTOP are not
lowercase_desktops="$(printf '%s' "${XDG_CURRENT_DESKTOP-}" | tr '[:upper:]' '[:lower:]')"
debug "lowercase desktops are: '$lowercase_desktops'"
# All config files are searched for, and read immediatelly, rather than when out of IDs
# This way all possible IDs are know before iterating over them, and are in order of preference
# Further down, duplicate IDs are then removed using `awk`
# This avoids having to use cumbersome blacklists, or fragile string operations, to deal with them
IFS=':'
for config_dir in $CONF_HIERARCHY; do
	# Append read ID(s) to list, using brace expansion for better readability
	IFS=':'
	for desktop in $lowercase_desktops; do
		IFS="$OIFS"
		ENTRY_IDS="${ENTRY_IDS}${N}$(read_config_path "$config_dir"/"$desktop"-"$CONFIG_NAME")"
	done
	IFS="$OIFS"
	ENTRY_IDS="${ENTRY_IDS}${N}$(read_config_path "$config_dir"/"$CONFIG_NAME")"
done

# whether to use entries in 'xdg-terminals' or stock terminals in 'applications'
# decide by checking for special lines in configs
# default is governed by XTE_STOCK_TERMINALS
STOCK_TERMINALS=$(
	# find special parameters in ENTRY_IDS
	while read -r LINE; do
		case "$LINE" in
		# special parameters to control data subdir and entry filtering
		use_stock_applications)
			debug "encountered use_stock_applications"
			echo true
			break
			;;
		use_xdg_terminals)
			debug "encountered use_xdg_terminals"
			echo false
			break
			;;
		esac
	done <<- EOL
		$ENTRY_IDS
	EOL
)

if [ -z "$STOCK_TERMINALS" ]; then
	debug "no stock terminals control in configs, XTE_STOCK_TERMINALS: ${XTE_STOCK_TERMINALS:-undefined}"
	STOCK_TERMINALS=${XTE_STOCK_TERMINALS:-false}
fi

debug "STOCK_TERMINALS=$STOCK_TERMINALS"

# drop special and empty lines from ENTRY_IDS, deduplicate
ENTRY_IDS=$(
	LIST=''
	while read -r LINE; do
		case "$LINE" in
		use_stock_applications | use_xdg_terminals | '') continue ;;
		*) LIST=$(append "$LIST" "$LINE") ;;
		esac
	done <<- EOL
		$ENTRY_IDS
	EOL
	printf '%s' "$LIST"
)

debug "final entry ID list '$ENTRY_IDS'"

# select DATA_PREFIX_DIR and entry filtering:
# operate in separate "xdg-terminals" subdirs (default),
# or filter terminals from native "applications" subdirs by category
if check_bool "$STOCK_TERMINALS"; then
	debug "filtering stock terminal entries from applications"
	DATA_PREFIX_DIR=applications
	list_entry_files() {
		find -L "$1" -type f -iname '*.desktop' -print0 |
			xargs -0r grep -ZlE '^[[:space:]]*Categories[[:space:]]*=[[:space:]]*(.*;)?TerminalEmulator(;|$)' |
			sort -z | tr '\0' '\n'
	}
else
	debug "getting terminal entries from xdg-terminals"
	DATA_PREFIX_DIR=xdg-terminals
	list_entry_files() {
		find -L "$1" -type f -iname '*.desktop' -print0 |
			sort -z | tr '\0' '\n'
	}
fi

# Generate list of possible terminal entry files and also add their IDs to
IFS=':'
for data_dir in $DATA_HIERARCHY; do
	IFS="$OIFS"
	if [ -d "$data_dir"/"$DATA_PREFIX_DIR" ]; then
		debug "searching in '$data_dir/$DATA_PREFIX_DIR'"
		while read -r entry_path; do
			[ -z "$entry_path" ] && continue
			debug "found desktop entry '$entry_path'"
			# Remove data directory path
			entry_path="${entry_path#"$data_dir"/"$DATA_PREFIX_DIR"/}"
			# Create entry ID from path
			entry_id="$(printf '%s' "$entry_path" | tr '/' '-')"
			debug "adding matching id '$entry_id'"
			# Append found ID to list, using brace expansion for better readability
			ENTRY_IDS="${ENTRY_IDS}${N}${entry_id}"
			# Prepend data directory path, and delimit its end using an extra '/' character
			# This is done so the ID can be recreated in `find_entry_path`
			# Other possible way of storing the data direcotry could be:
			# $data_dir/$DATA_PREFIX_DIR/$entry_path/$entry_id
			# Where '.desktop/' is the delimiter, as IDs do not contain '/', and entry files must end in '.desktop'
			entry_path="$data_dir"/"$DATA_PREFIX_DIR"//"$entry_path"
			# Append found path to list, using brace expansion for better readability
			ENTRY_PATHS="${ENTRY_PATHS}${N}${entry_path}"
			# Print order of found files is unpredictable, sort them
		done <<- EOF
			$(list_entry_files "$data_dir"/"$DATA_PREFIX_DIR")
		EOF
	fi
done

# Loop through IDs, any empty lines should be discarded by word splitting
IFS="$N"
for entry_id in $ENTRY_IDS; do
	# See read_entry_path and check_entry
	if read_entry_path "$(find_entry_path "$entry_id")"; then
		# Default to '-e' if unset
		EXECARG=${EXECARG-'-e'}
		break
	fi
done
IFS="$OIFS"

if [ -z "${EXEC-}" ]; then
	# Set defaults
	EXEC='xterm'
	EXECARG='-e'
fi

# Store original argument list, before it's modified
ORIG_ARGV="$*"

# `Implementations must undo quoting [in the Exec argument(s)][...]`
if [ "$#" -gt 0 ]; then
	eval "set -- $EXEC ${EXECARG:+'"$EXECARG"'} \"\$@\""
else
	eval "set -- $EXEC"
fi

debug "EXEC=$EXEC
EXECARG=$EXECARG
ARGV=$ORIG_ARGV
Final argv (>arg< per line):
$(printf '>%s<\n' "$@")
End of final argv"

exec "$@"
