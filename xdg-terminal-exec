#!/bin/sh
# Proposal for XDG terminal execution utility
#
# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.
#
# Contributors:
# Roman Chistokhodov https://github.com/FreeSlave/

# some transitional variables for desktop entries used here:
# ENTRY_FILE - desktop entry path relative to it's data directory
# ENTRY_ID - ENTRY_FILE with '/' swapped for '-' (see section E of Desktop Entry Spec)
# ENTRY_PATH - full path of specific desktop entry file

# Treat non-zero exit status from simple commands as an error
# Treat unset variables as errors when performing parameter expansion
set -eu

DATA_PREFIX_DIR=xdg-terminals
CONFIG_NAME=xdg-terminals.list

DATA_HIERARCHY="${XDG_DATA_HOME:-$HOME/.local/share}:${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
CONF_HIERARCHY="${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg:/usr/etc/xdg}"

DATA=''
BLACKLIST=''
EXEC=''
EXECARG=''

OIFS="$IFS"

if [ "${DEBUG-0}" = '1' ]; then
	debug() { printf '%s\n' "$1" >&2; }
else
	debug() { :; }
fi

trim_start() {
	# Remove all but leading whitespace, and trim that from the given string
	printf '%s' "${1#"${1%%[![:space:]]*}"}"
}

trim_spaces() {
	TRIMVAR="$*"
	TRIMVAR="${TRIMVAR#"${TRIMVAR%%[![:space:]]*}"}"
	TRIMVAR="${TRIMVAR%"${TRIMVAR##*[![:space:]]}"}"
	printf '%s' "$TRIMVAR"
}

trim_comment() {
	TRIMVAR="$*"
	TRIMVAR="${TRIMVAR%%#*}"
	printf '%s' "$TRIMVAR"
}

generate_config_list() {
	# Generate list of possible config files for current DE
	DESKTOPS_LC="$(printf '%s' "${XDG_CURRENT_DESKTOP-}" | tr '[:upper:]' '[:lower:]')"
	IFS=':'
	debug "lower case desktops are: '${DESKTOPS_LC}'"
	for CONFIG_DIR in $CONF_HIERARCHY; do
		for DESKTOP in $DESKTOPS_LC; do
			printf '%s\n' "${CONFIG_DIR}/${DESKTOP}${DESKTOP:+-}${CONFIG_NAME}"
		done
		printf '%s\n' "${CONFIG_DIR}/${CONFIG_NAME}"
	done | uniq
	IFS="$OIFS"
}

find_preferred_entry() {
	# Read entries listed in config files until a valid one is found
	CONFIG_LIST="$(generate_config_list)"

	debug 'finding preferred entry in configs'

	while read -r CONFIG_FILE; do
		debug "looking for config '${CONFIG_FILE}'"
		if [ -f "${CONFIG_FILE}" ]; then
			debug "reading config '${CONFIG_FILE}'"
			while read -r LINE; do
				debug "parsing line '$LINE'"
				LINE="$(trim_comment "$LINE")"
				LINE="$(trim_spaces "$LINE")"
				[ -z "$LINE" ] && continue || ENTRY_ID="$LINE"
				debug "retrieved entry ID '$ENTRY_ID'"
				check_entry_id "$ENTRY_ID" || continue

				debug "finding path for entry ID '$ENTRY_ID'"
				ENTRY_PATH="$(find_entry_path "$ENTRY_ID")"
				if [ -n "$ENTRY_PATH" ] && check_entry_path "$ENTRY_PATH"; then
					debug "file at path '$ENTRY_PATH' checks out"
					printf '%s' "$ENTRY_PATH"
					return 0
				else
					debug "entry ID '$ENTRY_ID' failed check at path '$ENTRY_PATH', blacklisting"
					BLACKLIST="${BLACKLIST}${BLACKLIST:+;}$ENTRY_ID"
					continue
				fi
			done < "${CONFIG_FILE}"
		fi
	done <<- EOF
		$CONFIG_LIST
	EOF
}

find_any_entry() {
	# Read entries in data dirs until a valid one is found
	debug 'looking for first available entry in data hierarchy'
	IFS=':'
	for DATA_DIR in $DATA_HIERARCHY; do
		IFS="$OIFS"
		if [ -d "${DATA_DIR}/${DATA_PREFIX_DIR}" ]; then
			debug "searching in '${DATA_DIR}/${DATA_PREFIX_DIR}'"
			ENTRY_FILES="$(find -L "${DATA_DIR}/${DATA_PREFIX_DIR}" -type f -iname '*.desktop')"
			while read -r ENTRY_PATH; do
				[ -z "$ENTRY_PATH" ] && continue
				ENTRY_FILE="${ENTRY_PATH#"${DATA_DIR}/${DATA_PREFIX_DIR}/"}"
				ENTRY_ID="$(printf '%s' "$ENTRY_FILE" | tr '/' '-')"
				check_entry_id "$ENTRY_ID" || continue
				if check_entry_path "$ENTRY_PATH"; then
					debug "file at path '$ENTRY_PATH' checks out"
					printf '%s' "$ENTRY_PATH"
					return 0
				else
					debug "entry ID '$ENTRY_ID' failed check at path '$ENTRY_PATH', blacklisting"
					BLACKLIST="${BLACKLIST}${BLACKLIST:+;}$ENTRY_ID"
					debug "current blacklist: '$BLACKLIST'"
				fi
			done <<- EOF
				$ENTRY_FILES
			EOF
		fi
	done
	IFS="$OIFS"
}

find_entry_path() {
	# For given desktop entry ID find an actual file path
	ENTRY_ID="$1"

	IFS=':'
	for DATA_DIR in $DATA_HIERARCHY; do
		IFS="$OIFS"
		if [ -d "${DATA_DIR}/${DATA_PREFIX_DIR}" ]; then
			debug "looking in '${DATA_DIR}/${DATA_PREFIX_DIR}'"
			ENTRY_FILES="$(find -L "${DATA_DIR}/${DATA_PREFIX_DIR}" -type f -iname '*.desktop')"
			while read -r ENTRY_PATH; do
				[ -z "$ENTRY_PATH" ] && continue
				ENTRY_FILE="${ENTRY_PATH#"${DATA_DIR}/${DATA_PREFIX_DIR}/"}"
				FOUND_ENTRY_ID="$(printf '%s' "$ENTRY_FILE" | tr '/' '-')"
				[ "$FOUND_ENTRY_ID" != "$ENTRY_ID" ] && continue
				debug "got entry path '$ENTRY_PATH'"
				printf '%s' "$ENTRY_PATH"
				return 0
			done <<- EOF
				$ENTRY_FILES
			EOF
		fi
	done
	IFS="$OIFS"
	debug "path not found for entry ID '$ENTRY_ID'"
	return 1
}

check_entry_id() {
	# Check if entry ID is blacklisted by previous checks
	ENTRY_ID="$1"

	debug "checking if ID '$ENTRY_ID' is in blacklist '$BLACKLIST'"
	IFS=';'
	for ITEM in $BLACKLIST; do
		IFS="$OIFS"
		if [ "$ENTRY_ID" = "$ITEM" ]; then
			debug 'blacklist positive'
			return 1
		fi
	done
	IFS="$OIFS"
	return 0
}

# Check validity of a given entry line
# Modifies following global variables:
# EXEC : Program to execute, possibly with arguments. See spec for details.
# EXECARG : Execution argument for the terminal emulator.
check_entry() {
	# Order of checks is important
	case $1 in
	'OnlyShowIn'*=*)
		onlyShowIn=$(trim_start "${1#*=}")
		debug "read OnlyShowIn '$onlyShowIn'"
		IFS=';'
		for name in $onlyShowIn; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				IFS="$OIFS"
				debug "checking OnlyShowIn match '$desktop'='$name'"
				[ "$desktop" = "$name" ] && return 0
			done
		done
		IFS="$OIFS"
		# Default in this case is to fail
		return 1
		;;
	'NotShowIn'*=*)
		notShowIn=$(trim_start "${1#*=}")
		debug "read NotShowIn '$notShowIn'"
		IFS=';'
		for name in $notShowIn; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				IFS="$OIFS"
				debug "checking NotShowIn match '$desktop'='$name'"
				[ "$desktop" = "$name" ] && return 1
			done
		done
		IFS="$OIFS"
		# Default in this case is to succeed
		return 0
		;;
	'X-ExecArg'*=*)
		# Set global variable
		EXECARG=$(trim_start "${1#*=}")
		debug "read execution argument '$EXECARG'"
		;;
	'ExecArg'*=*)
		# Set global variable
		EXECARG=$(trim_start "${1#*=}")
		debug "read execution argument '$EXECARG'"
		;;
	'TryExec'*=*)
		executable=$(trim_start "${1#*=}")
		debug "checking TryExec executable '$executable'"
		command -v "$executable" > /dev/null || return 1
		;;
	'Hidden'*=*)
		hidden=$(trim_start "${1#*=}")
		debug "checking Hidden boolean '$hidden'"
		[ "$hidden" = 'true' ] && return 1
		;;
	'Exec'*=*)
		# Set global variable
		EXEC=$(trim_start "${1#*=}")
		# Get first word from read Exec value
		eval "set -- $EXEC"
		exec0="$1"
		debug "checking Exec[0] executable '$exec0'"
		command -v "$exec0" > /dev/null || return 1
		;;
	esac
	# By default unrecognised keys, empty lines and comments get ignored
}

check_entry_path() {
	# Determine if entry in given path is valid for execution in current DE
	for line in $(read_entry_path "$1"); do
		check_entry "$line" || return 1
	done
	return 0
}

# Read entry from given path, only parse 'Desktop Entry' group
read_entry_path() {
	entry_path="$1"

	debug "reading desktop entry '$entry_path'"
	# Let `read` trim leading/trailing whitespace from the line
	while read -r line; do
		case $line in
		# `There should be nothing preceding [the Desktop Entry group] in the desktop entry file but [comments]`
		'[Desktop Entry]'*) ;;
		# A `Key=Value` pair, print it
		[A-Za-z0-9-]*) printf '%s\n' "$line" ;;
		# Start of the next group header, stop
		'['*) break ;;
		esac
		# By default empty lines and comments get ignored
	done < "$entry_path"
	return 0
}

ENTRY_PATH="$(find_preferred_entry)"
[ -z "$ENTRY_PATH" ] && ENTRY_PATH="$(find_any_entry)"

if [ -n "$ENTRY_PATH" ]; then
	DATA="$(read_entry_path "$ENTRY_PATH")"
	EXEC="$(printf '%s\n' "$DATA" | grep '^[[:space:]]*Exec[[:space:]]*=' | head -n 1 | cut -d = -f 2-)"
	EXEC="$(trim_spaces "$EXEC")"
	EXECARG="$(printf '%s\n' "$DATA" | grep '^[[:space:]]*ExecArg[[:space:]]*=' | head -n 1)"
	EXECARG="$(trim_spaces "$EXECARG")"
	if [ -z "$EXECARG" ]; then
		EXECARG="$(printf '%s\n' "$DATA" | grep '^[[:space:]]*X-ExecArg[[:space:]]*=' | head -n 1)"
		EXECARG="$(trim_spaces "$EXECARG")"
	fi
	[ -z "$EXECARG" ] && EXECARG='ExecArg=-e'
	EXECARG="$(printf '%s\n' "$EXECARG" | cut -d = -f 2-)"
	EXECARG="$(trim_spaces "$EXECARG")"
else
	EXEC='xterm'
	EXECARG='-e'
fi

ORIG_ARGV="$*"

if [ "$#" -gt 0 ]; then
	if [ -n "$EXECARG" ]; then
		eval "set -- $EXEC \"\$EXECARG\" \"\$@\""
	else
		eval "set -- $EXEC \"\$@\""
	fi
else
	eval "set -- $EXEC"
fi

debug "EXEC=$EXEC
EXECARG=$EXECARG
ARGV=$ORIG_ARGV
Final argv (>arg< per line):
$(printf '>%s<\n' "$@")
End of final argv"

exec "$@"
